equals와 hashCode 재정의
	어떤 데이터들을 저장해 놓았다가 다시 불러올 때
	새로운 객체로 만들면서 (객체화 하면서) 객체로 정보를 가져오게 된다.
	따라서 new 생성자 ()가 호출되는 순간 새로운 객체로 만들어지기 때문에
	안에 들어있는 데이터들은 서로 같지만, 주소가 다른 객체가 생길 수 있다.
	하지만 그 둘은 같은 위상 (같은 정보들을 담고있는 객체)의 객체이기 때문에
	equals()로 비교를 했을 때 true로 나오게 해야한다.
	따라서 Object 클래스에 있는 equals()는 주소비교이기 때문에, 우리가
	만든 클래스에서는 equals()를 특정한 어떤 값을 비교하는걸로 재정의
	해주어야 한다, 마찬가지로 hashCode()도 Onject 클래스에서는 주소값과  
	관련된 어떠한 정수값이기 때문에, 우리 클래스에서는 새로운 형식으로 재정의
	해주어야 한다.

Wrapper Class
	int, double, char, ... : 원시타입, 기본형 타입
	integer, Double, Character : 클래스타입(Wrapper Class)

	Wrapper클래스 객체명 = new Wrapper클래스생성자(기본형값); : 박싱
	객체명.~~Value() : 언박싱

Wrapper 클래스 사용이유
	기본형 타입을 객체로 다루어야 할 때
	매개변수로 객체를 넘길 때( Object 객체에 값을 넘겨줄 때 )
	기본형 타입이 아닌 객체로 값을 저장해야 할 때
	객체간의 비교가 필요할 때

jdk 1.5버전부터 오토박싱, 오토언박싱을 지원한다.
	Wrapper클래스 객체명 = 기본형값;
	기본형 변수명 = 객체;
------------------------------------------------------------------------
Generic( 제네릭 )
	자료형을 정하지 않는 기법(사용부에서 지정해주어야 한다.)

<E> : Element
<T> : Type 
<K> : Key
<V> : Value
<N> : Number
제네릭 클래스
	클래스 내부에서 사용된 자료형을 지정한다

	class 클래스명<타입>{
	
	}
제네릭 메소드
	<타입,...>리턴타입 메소드명(){

	}
제네릭 인터페이스
	interface 인터페이스명<타입,...>{

	}
--------------------------------------------------------------------------------
컬렉션 프레임워크(Collection Framework)
	많은 데이터들을 쉽고 효과적으로 관리할 수 있는
	표준화된 방법을 제공하는 클래스 및 인터페이스들의 집합

컬렉션 프레임워크의 주요 인터페이스

	Collection

1. List extends Collection

2. Set extends Collection

List 인터페이스로 구현된 클래스
	-Vector
	-ArrayList
	-LinkedList

Set 인터페이스로 구현된 클래스
	-HashSet	
	-TreeSet

ArrayList

	컬렉션 클래스중 가장 많이 사용되는 클래스
	배열을 이용해서 값을 저장한다.

	인덱스를 이용해서 배열요소에 빠르게 접근이 가능하지만,
	크기를 늘리기 위해서 새로운 배열을 생성하고 기존의 값들을
	옮겨야 하므로 느리다.

	배열은 처음에 몇칸을 할당할지 고정시킬 수 있지만
	ArrayList는 값을 넣는 만큼 자동으로 늘어난다.

Collections
	다양한 자료구조가 구현된 클래스
	내부에 있는 static 메소드들(shuffle, sort, reverse,..)을
	사용하라고 만들어져 있는 클래스이다.










