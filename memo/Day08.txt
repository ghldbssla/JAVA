클래스(반)
	공통 요소가 모여있는 곳
	변수와 메소드 둘다 관리, 사용 하기 위한 목적

	1. 주어이다.
		모든 문장 맨 앞에 클래스가 나오고
		영어는 맨 앞을 항상 대문자로 적는다.
		따라서 주어가 클래스이고, 대문자로 시작한다.

		Monkey.eat("banana");
		원숭이가 바나나를 먹는다.
		[주어]  [목적어] [동사]

	2. 타입이다.
		클래스는 추상적인 개념(사람,동물과 같음)이고 이 클래스 안에는 필드가 존재한다.
		따라서 필드에 접근하기 위해서는 추상적인 개념을 구체화시킨  
		 "객체"가 필요하다.(Instance Variable)

		instance는 예, 예시이고 추상적인 개념의 한 예시로서
		객체가 나오기 때문에 instance variable이라고 부른다.
		(자동차인데 예를들면 엄마차 말이야)

		클래스를 객체로 만들어내는 작업을 객체화라고 한다.
		
		클래스명 객체명;
		클래스명 객체명 = new 클래스명();
		
		따라서 클래스는 객체의 타입이다.

클래스 선언
	class 클래스명{
		필드(객체[->변수], 메소드)
	}

클래스의 사용
	[객체화]
	클래스명 객체명 = new 클래스명();
	객체명.필드명

	필드에는 여러개의 값이 존재하기 때문에 하나의 저장공간(객체명)에는
	필드 통채로는 담을수 없다. 따라서 필드는 다른곳(Heap영역)에 할당되고
	할당된 주소값을 저장하는 것이 바로 객체이다.

생성자
	클래스명()
	생성자는 메소드와 똑같은 기능을 가지고 있지만
	(무조건 주소값을 리턴해야해서)
	리턴이 없기 때문에 메소드라고 부르지 않는다.

	클래스 선언시 자동으로 생성자가 만들어지고 코드상에는 나타나지 않는다.
	이런 생성자를 기본 생성자라고 하며, 직접 생성자를 선언하게 되면
	기본 생성자가 자동으로 추가되지 않는다.

생성자의 목적
	1. 클래스의 필드를 메모리에 할당해주고, 할당된 주소값을 가지고 온다.
	이주소값을 객체에 넣어주는 작업이 객체화이다.

	2. 초기화의 목적

this
	클래스 선언시 내부적으로 선언되어 생성된다.
	클래스 필드에 있는 메소드는 한번의 선언으로 여러 객체를 다루어야 한다.
	메소드 내에서 필드를 사용하고자 할때 어떤 객체의 필드인지를 알 수 없다.
	따라서 객체에 마침표를 찍고 필드에 접근하면 그객체의 주소가 this에
	담기게 된다. 결과적으로 this.필드명으로 접근하면 여러 객체도 하나의 메소드에서 
	구분하여 다룰 수 있게 된다.

polymorphism(다형성)
	1. 오버로딩 (OverLoading) - 같은 이름의 메소드(매개변수가 다름)
		같은 이름의 메소드를 넘쳐서(여러개) 불러오는 기법
		매개변수의 개수 혹은 타입이 다르면 같은 이름으로 여러 메소드를
		선언할 수 있다.(이름이 아닌 매개변수로 구분할 수 있기 때문)
		오버로딩된 메소드 사용시 전달한 값의 타입 혹은 개수로 구분하여
		알맞은 메소드로 찾아가 작업을 한다.

	2. 오버라이딩 (->나중에)
Alt+Shift+s
Generater constructor using fields
기본생성자 단축키

클래스 배열
	객체를 여러개 선언해야 하는 경우 배열 타입으로 한번에 선언 후 사용
	각 객체의 규칙성이 없다면, 규칙성을 부여하기 위해서도 사용한다.

	클래스명[] 배열명 = {new 생성자(),new 생성자(),...};
	클래스명[] 배열명 = new 클래스명[칸수];

클래스 배열의 사용
	배열명[idx].필드명;


















